name: Validate PR Checklist

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]
    branches: [main]

jobs:
  validate-pull-request-checklist:
    runs-on: ubuntu-latest
    steps:
      - name: Validate PR checklist
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Configuration: section headers and minimum checked items required
            const checks = [
              { header: "## Types of changes", minChecked: 1 },
              { header: "## Details of changes", minChecked: 1 },
              { header: "## Dev Checklist", minChecked: 9 },
              { header: "## This Change Needs APIM Update?", minChecked: 1 },
              { header: "## Pipeline", minChecked: 3 },
              { header: "## Deployment labels added", minChecked: 1 },
            ];
            
            // Additional text requirements: ensure author wrote some text in specific sections
            // minChars: minimal number of non-whitespace characters after stripping comments/checkboxes/markup
            // disallowPatterns: fail if section includes any placeholder pattern
            // requirePatterns: optional list of regexes that must be present in the section
            const textRequirements = [
              { header: "## Description", minChars: 20, disallowPatterns: [/\(Deployment to:ENV\)/i] },
              { header: "## Add User Story link", minChars: 10 },
            ];
            
            // Only count lowercase x as per original pattern "- [x]"
            const checkedBoxRegex = /- \[x\]/g;
            
            // Get the latest PR body from the API (more reliable than context.payload in some events)
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });
            const body = pr.body || "";
            
            // Helper to extract a section body by header until the next header of same/larger level
            function extractSection(markdown, headerText) {
              // Match the exact header line (start of line, optional spaces), then capture until next header (## or #) or end
              const headerPattern = new RegExp(
                String.raw`(^|\n)\s*${headerText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\s*\n` +
                String.raw`([\s\S]*?)(?=\n\s*#{1,6}\s|$)`,
                'i'
              );
              const m = markdown.match(headerPattern);
              return m ? m[2] : null;
            }
            
            // Strip comments, checkboxes, and common markdown syntax to get meaningful text
            function normalizeText(s) {
              return (s ?? '')
                // Remove HTML comments
                .replace(/<!--[\s\S]*?-->/g, '')
                // Remove checkbox lines entirely
                .replace(/^\s*-\s*\[[ xX]\].*$/gm, '')
                // Remove fenced code blocks
                .replace(/```[\s\S]*?```/g, '')
                // Remove inline code
                .replace(/`[^`]*`/g, '')
                // Remove markdown headings, list markers, bold/italic markers
                .replace(/^\s*#{1,6}\s+/gm, '')
                .replace(/^\s*[-*+]\s+/gm, '')
                .replace(/\*\*?|__?|~~/g, '')
                // Collapse whitespace
                .replace(/[ \t]+\n/g, '\n')
                .trim();
            }
            
            let failures = [];
            
            // Checkbox validations
            for (const { header, minChecked } of checks) {
              const section = extractSection(body, header);
              if (section === null) {
                failures.push(`Missing section header: "${header}"`);
                continue;
              }
              const matches = section.match(checkedBoxRegex);
              const count = matches ? matches.length : 0;
              if (count < minChecked) {
                failures.push(`Section "${header}": requires at least ${minChecked} checked item(s), but found ${count}.`);
              }
            }
            
            // Text validations
            for (const rule of textRequirements) {
              const section = extractSection(body, rule.header);
              if (section === null) {
                failures.push(`Missing section header: "${rule.header}"`);
                continue;
              }
              const text = normalizeText(section);
              if ((text.replace(/\s+/g, '').length) < (rule.minChars || 1)) {
                failures.push(`Section "${rule.header}": please add meaningful text (min ${rule.minChars} non-whitespace chars).`);
              }
              if (rule.disallowPatterns) {
                for (const pat of rule.disallowPatterns) {
                  if (pat.test(section)) {
                    failures.push(`Section "${rule.header}": remove placeholder text matching ${pat}.`);
                  }
                }
              }
              if (rule.requirePatterns) {
                for (const pat of rule.requirePatterns) {
                  if (!pat.test(section)) {
                    failures.push(`Section "${rule.header}": must include text matching ${pat}.`);
                  }
                }
              }
            }
            
            if (failures.length) {
              core.setFailed('PR validation failed:\n' + failures.map(f => `- ${f}`).join('\n'));
            } else {
              core.info('All required checklist and text sections are satisfied.');
            }